# 背包问题
# 一个小偷有4磅的背包空间，现有物品如下，如何拿保证物品的价值加起来最大
# 吉他 1磅 1500元
# 音响 4磅 3000元
# 电脑 3磅 2000元
# 手机 1磅 2000元

# 求解（《图解算法》，最基本的解法）：
#                   { 上一个单元格的 optp[i][j] (不拿)
# optp[i][j] =  max {
#                   { 当前物品i的价值p[i] + 剩余空间的最大价值optp[i-1][j-当前物品的重量w[i]]

# w[1]-w[4],p[1]-p[4]分别为吉他、音响、电脑、手机和它们的价格
w = [0, 1, 4, 3, 1]  # weight，保存每件物品重量的数组，其中w[0]无实际用处，只是为了接下来的实现序号方便
p = [0,1500,3000,2000,2000] # price,保存每件物品的价格，p[0]同理
n = len(w)-1 # 统计物品的数量
m = 4 # 背包空间上限

x = [] # 保存背包取最大值时的物品序号
v = 0 # 取得的最大值
optp = [[0 for col in range(m+1)] for raw in range(n+1)] #建立一个全为0的n*m的数组，n表示物品，m表示背包的重量

def bag(w,p,n,m,x):
    # 计算optp中的值
    for i in range(1,n+1): #i表示物品
        for j in range(1,m+1): #j表示重量
            if (j >= w[i]): #w[i]表示当前加入物品的重量，当前物品能放入j的背包中
                # optp[i-1][j]不拿当前物品获得的价值，optp[i-1][j-w[i]]+p[i]拿当前物品获得的最大价值
                optp[i][j] = max(optp[i-1][j],optp[i-1][j-w[i]]+p[i])
            else: # j<w[i],不能放入，不用考虑该物品了
                optp[i][j] = optp[i-1][j]
    # 找到取最大值时拿了那些物品
    # 方法是找到optp[i][j]和optp[i-1][j]跳变的地方，表示拿了该物品i
    j = m
    for i in range(n,0,-1):
        if optp[i][j] > optp[i-1][j]: # 如果跳变了，那么拿了该物品
            x.append(i)  # 保存物品序号
            j = j - w[i] # 拿了物品减去其重量

    v = optp[n][m] # optp最后一个值便是问题的解
    return v


print("最大价值为",bag(w,p,n,m,x))
print("拿取的物品索引为",x)